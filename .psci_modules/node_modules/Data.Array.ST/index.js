
// | Helper functions for working with mutable arrays using the `ST` effect.

// |

// | This module can be used when performance is important and mutation is a local effect.
"use strict";
var $foreign = require("./foreign");
var Control_Applicative = require("../Control.Applicative");
var Control_Bind = require("../Control.Bind");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_ST = require("../Control.Monad.ST");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Maybe = require("../Data.Maybe");
var Prelude = require("../Prelude");
var Unsafe_Coerce = require("../Unsafe.Coerce");

// | O(1). Convert a mutable array to an immutable array, without copying. The mutable

// | array must not be mutated afterwards.
var unsafeFreeze = function ($7) {
    return Control_Applicative.pure(Control_Monad_Eff.applicativeEff)(Unsafe_Coerce.unsafeCoerce($7));
};

// | Create a mutable copy of an immutable array.
var thaw = $foreign.copyImpl;

// | Perform an effect requiring a mutable array on a copy of an immutable array,

// | safely returning the result as an immutable array.
var withArray = function (f) {
    return function (xs) {
        return function __do() {
            var v = thaw(xs)();
            var v1 = f(v)();
            return unsafeFreeze(v)();
        };
    };
};

// | Append an element to the end of a mutable array. Returns the new length of

// | the array.
var pushSTArray = function (arr) {
    return function (a) {
        return $foreign.pushAllSTArray(arr)([ a ]);
    };
};

// | Read the value at the specified index in a mutable array.
var peekSTArray = $foreign.peekSTArrayImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

// | Mutate the element at the specified index using the supplied function.
var modifySTArray = function (xs) {
    return function (i) {
        return function (f) {
            return function __do() {
                var v = peekSTArray(xs)(i)();
                if (v instanceof Data_Maybe.Just) {
                    return $foreign.pokeSTArray(xs)(i)(f(v.value0))();
                };
                if (v instanceof Data_Maybe.Nothing) {
                    return false;
                };
                throw new Error("Failed pattern match at Data.Array.ST line 120, column 3 - line 122, column 26: " + [ v.constructor.name ]);
            };
        };
    };
};

// | Create an immutable copy of a mutable array.
var freeze = $foreign.copyImpl;
module.exports = {
    freeze: freeze, 
    modifySTArray: modifySTArray, 
    peekSTArray: peekSTArray, 
    pushSTArray: pushSTArray, 
    thaw: thaw, 
    unsafeFreeze: unsafeFreeze, 
    withArray: withArray, 
    emptySTArray: $foreign.emptySTArray, 
    pokeSTArray: $foreign.pokeSTArray, 
    pushAllSTArray: $foreign.pushAllSTArray, 
    runSTArray: $foreign.runSTArray, 
    spliceSTArray: $foreign.spliceSTArray, 
    toAssocArray: $foreign.toAssocArray
};
