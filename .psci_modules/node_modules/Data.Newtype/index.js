"use strict";
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Function = require("../Data.Function");
var Data_Functor = require("../Data.Functor");
var Prelude = require("../Prelude");

// | A type class for `newtype`s to enable convenient wrapping and unwrapping,

// | and the use of the other functions in this module.

// |

// | The compiler can derive instances of `Newtype` automatically:

// |

// | ``` purescript

// | newtype EmailAddress = EmailAddress String

// |

// | derive instance newtypeEmailAddress :: Newtype EmailAddress _

// | ```

// |

// | Note that deriving for `Newtype` instances requires that the type be

// | defined as `newtype` rather than `data` declaration (even if the `data`

// | structurally fits the rules of a `newtype`), and the use of a wildcard for

// | the wrapped type.

// |

// | Instances must obey the following laws:

// | ``` purescript

// | unwrap <<< wrap = id

// | wrap <<< unwrap = id

// | ```
var Newtype = function (unwrap, wrap) {
    this.unwrap = unwrap;
    this.wrap = wrap;
};
var wrap = function (dict) {
    return dict.wrap;
};
var unwrap = function (dict) {
    return dict.unwrap;
};

// | Much like `under2`, but where the lifted binary function operates on

// | values in a `Functor`.
var underF2 = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($50) {
                            return function ($51) {
                                return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(Data_Function.on(f)(Data_Functor.map(dictFunctor)(wrap(dictNewtype)))($50)($51));
                            };
                        };
                    };
                };
            };
        };
    };
};

// | Much like `under`, but where the lifted function operates on values in a

// | `Functor`:

// |

// | ``` purescript

// | newtype EmailAddress = EmailAddress String

// | derive instance newtypeEmailAddress :: Newtype EmailAddress _

// |

// | isValid :: EmailAddress -> Boolean

// | isValid x = false -- imagine a slightly less strict predicate here

// |

// | findValidEmailString :: Array String -> Maybe String

// | findValidEmailString = underF EmailAddress (Foldable.find isValid)

// | ```

// |

// | The above example also demonstrates that the functor type is polymorphic

// | here too, the input is an `Array` but the result is a `Maybe`.
var underF = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($52) {
                            return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($52)));
                        };
                    };
                };
            };
        };
    };
};

// | The opposite of `over2`: lowers a binary function that operates on `Newtype`d

// | values to operate on the wrapped value instead.
var under2 = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($53) {
                    return function ($54) {
                        return unwrap(dictNewtype1)(Data_Function.on(f)(wrap(dictNewtype))($53)($54));
                    };
                };
            };
        };
    };
};

// | The opposite of `over`: lowers a function that operates on `Newtype`d

// | values to operate on the wrapped value instead.

// |

// | ``` purescript

// | newtype Degrees = Degrees Number

// | derive instance newtypeDegrees :: Newtype Degrees _

// |

// | newtype NormalDegrees = NormalDegrees Number

// | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _

// |

// | normaliseDegrees :: Degrees -> NormalDegrees

// | normaliseDegrees (Degrees deg) = NormalDegrees (deg % 360.0)

// |

// | asNormalDegrees :: Number -> Number

// | asNormalDegrees = under Degrees normaliseDegrees

// | ```

// |

// | As with `over` the `Newtype` is polymorphic, as illustrated in the example

// | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,

// | so even though `normaliseDegrees` changes the result type we can still put

// | a `Number` in and get a `Number` out via `under`.
var under = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($55) {
                    return unwrap(dictNewtype1)(f(wrap(dictNewtype)($55)));
                };
            };
        };
    };
};

// | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`

// | function.
var un = function (dictNewtype) {
    return function (v) {
        return unwrap(dictNewtype);
    };
};

// | Similar to the function from the `Traversable` class, but operating within

// | a newtype instead.
var traverse = function (dictFunctor) {
    return function (dictNewtype) {
        return function (v) {
            return function (f) {
                return function ($56) {
                    return Data_Functor.map(dictFunctor)(wrap(dictNewtype))(f(unwrap(dictNewtype)($56)));
                };
            };
        };
    };
};

// | Much like `over2`, but where the lifted binary function operates on

// | values in a `Functor`.
var overF2 = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($57) {
                            return function ($58) {
                                return Data_Functor.map(dictFunctor1)(wrap(dictNewtype1))(Data_Function.on(f)(Data_Functor.map(dictFunctor)(unwrap(dictNewtype)))($57)($58));
                            };
                        };
                    };
                };
            };
        };
    };
};

// | Much like `over`, but where the lifted function operates on values in a

// | `Functor`:

// |

// | ``` purescript

// | findLabel :: String -> Array Label -> Maybe Label

// | findLabel s = overF Label (Foldable.find (_ == s))

// | ```

// |

// | The above example also demonstrates that the functor type is polymorphic

// | here too, the input is an `Array` but the result is a `Maybe`.
var overF = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($59) {
                            return Data_Functor.map(dictFunctor1)(wrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(unwrap(dictNewtype))($59)));
                        };
                    };
                };
            };
        };
    };
};

// | Lifts a binary function to operate over newtypes.

// |

// | ``` purescript

// | newtype Meter = Meter Int

// | derive newtype instance newtypeMeter :: Newtype Meter _

// | newtype SquareMeter = SquareMeter Int

// | derive newtype instance newtypeSquareMeter :: Newtype SquareMeter _

// |

// | area :: Meter -> Meter -> SquareMeter

// | area = over2 Meter (*)

// | ```

// |

// | The above example also demonstrates that the return type is polymorphic

// | here too.
var over2 = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($60) {
                    return function ($61) {
                        return wrap(dictNewtype1)(Data_Function.on(f)(unwrap(dictNewtype))($60)($61));
                    };
                };
            };
        };
    };
};

// | Lifts a function operate over newtypes. This can be used to lift a

// | function to manipulate the contents of a single newtype, somewhat like

// | `map` does for a `Functor`:

// |

// | ``` purescript

// | newtype Label = Label String

// | derive instance newtypeLabel :: Newtype Label _

// |

// | toUpperLabel :: Label -> Label

// | toUpperLabel = over Label String.toUpper

// | ```

// |

// | But the result newtype is polymorphic, meaning the result can be returned

// | as an alternative newtype:

// |

// | ``` purescript

// | newtype UppercaseLabel = UppercaseLabel String

// | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _

// |

// | toUpperLabel' :: Label -> UppercaseLabel

// | toUpperLabel' = over Label String.toUpper

// | ```
var over = function (dictNewtype) {
    return function (dictNewtype1) {
        return function (v) {
            return function (f) {
                return function ($62) {
                    return wrap(dictNewtype1)(f(unwrap(dictNewtype)($62)));
                };
            };
        };
    };
};

// | Deprecated previous name of `un`.
var op = function (dictNewtype) {
    return un(dictNewtype);
};

// | Similar to the function from the `Distributive` class, but operating within

// | a newtype instead.
var collect = function (dictFunctor) {
    return function (dictNewtype) {
        return function (v) {
            return function (f) {
                return function ($63) {
                    return wrap(dictNewtype)(f(Data_Functor.map(dictFunctor)(unwrap(dictNewtype))($63)));
                };
            };
        };
    };
};

// | Similar to `ala` but useful for cases where you want to use an additional

// | projection with the higher order function:

// |

// | ``` purescript

// | alaF Additive foldMap String.length ["hello", "world"] -- 10

// | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0

// | ```

// |

// | The type admits other possibilities due to the polymorphic `Functor`

// | constraints, but the case described above works because ((->) a) is a

// | `Functor`.
var alaF = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictNewtype) {
            return function (dictNewtype1) {
                return function (v) {
                    return function (f) {
                        return function ($64) {
                            return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($64)));
                        };
                    };
                };
            };
        };
    };
};

// | This combinator is for when you have a higher order function that you want

// | to use in the context of some newtype - `foldMap` being a common example:

// |

// | ``` purescript

// | ala Additive foldMap [1,2,3,4] -- 10

// | ala Multiplicative foldMap [1,2,3,4] -- 24

// | ala Conj foldMap [true, false] -- false

// | ala Disj foldMap [true, false] -- true

// | ```
var ala = function (dictFunctor) {
    return function (dictNewtype) {
        return function (dictNewtype1) {
            return function (v) {
                return function (f) {
                    return Data_Functor.map(dictFunctor)(unwrap(dictNewtype))(f(wrap(dictNewtype1)));
                };
            };
        };
    };
};
module.exports = {
    Newtype: Newtype, 
    ala: ala, 
    alaF: alaF, 
    collect: collect, 
    op: op, 
    over: over, 
    over2: over2, 
    overF: overF, 
    overF2: overF2, 
    traverse: traverse, 
    un: un, 
    under: under, 
    under2: under2, 
    underF: underF, 
    underF2: underF2, 
    unwrap: unwrap, 
    wrap: wrap
};
