
// | Functions for working with PureScripts builtin `Number` type.
"use strict";
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Boolean = require("../Data.Boolean");
var Data_Maybe = require("../Data.Maybe");
var Global = require("../Global");
var Prelude = require("../Prelude");

// | Not a number (NaN).
var nan = Global.nan;

// | Test whether a `Number` is NaN.
var $$isNaN = Global["isNaN"];

// | Test whether a number is finite.
var $$isFinite = Global["isFinite"];

// | Positive infinity.
var infinity = Global.infinity;

// | Attempt to parse a `Number` using JavaScripts `parseFloat`. Returns

// | `Nothing` if the parse fails or if the result is not a finite number.

// |

// | Example:

// | ```purs

// | > fromString "123"

// | (Just 123.0)

// |

// | > fromString "12.34"

// | (Just 12.34)

// |

// | > fromString "1e4"

// | (Just 10000.0)

// |

// | > fromString "1.2e4"

// | (Just 12000.0)

// |

// | > fromString "bad"

// | Nothing

// | ```

// |

// | Note that `parseFloat` allows for trailing non-digit characters and

// | whitespace as a prefix:

// | ```

// | > fromString "  1.2 ??"

// | (Just 1.2)

// | ```
var fromString = (function () {
    var check = function (num) {
        if ($$isFinite(num)) {
            return new Data_Maybe.Just(num);
        };
        if (Data_Boolean.otherwise) {
            return Data_Maybe.Nothing.value;
        };
        throw new Error("Failed pattern match at Data.Number line 45, column 5 - line 46, column 39: " + [ num.constructor.name ]);
    };
    return function ($1) {
        return check(Global.readFloat($1));
    };
})();
module.exports = {
    fromString: fromString, 
    infinity: infinity, 
    "isFinite": $$isFinite, 
    "isNaN": $$isNaN, 
    nan: nan
};
